---
title: MachingLearning中的距离和相似性计算以及python实现
date: 2017-07-16 12:14:43
tags: [距离计算]
categories: 技术篇
---

# 前言
写这篇文章的目的不是说摘抄网上其他人的总结，刚才最近在看这方面的东西，为了让自己能够实际的去感受下每种求距离公式的差别，然后用python进行具体实现。
<!--More-->
在机器学习中，经常要用到距离和相似性的计算公式，我么要常计算个体之间的差异大小，继而评价个人之间的差异性和相似性，最常见的就是数据分析中的相关分析，数据挖掘中的分类和聚类算法。如利用k-means进行聚类时，判断个体所属的类别，要利用距离计算公式计算个体到簇心的距离，如利用KNN进行分类时，计算个体与已知类别之间的相似性，从而判断个体所属的类别等。


文章编辑的过程中或许存在一个错误或者不合理的地方，欢迎指正。

参考：http://www.cnblogs.com/heaad/archive/2011/03/08/1977733.html

推荐：https://my.oschina.net/hunglish/blog/787596

# 欧氏距离
也称欧几里得距离，是指在m维空间中两个点之间的真实距离。欧式距离在ML中使用的范围比较广，也比较通用，就比如说利用k-Means对二维平面内的数据点进行聚类，对魔都房价的聚类分析（price/m^2 与平均房价）等。
## 二维空间的欧氏距离 
二维平面上两点a(x1,y1)与b(x2,y2)间的欧氏距离

$$
d12 =\sqrt{(x_{1}-x_{2})^2+(y_{1}-y_{2})^2}
$$
python 实现为：

```
# coding: utf-8

from numpy import *

def twoPointDistance(a,b):
	d = sqrt( (a[0]-b[0])**2 + (a[1]-b[1])**2 )
	return d

print 'a,b 二维距离为：',twoPointDistance((1,1),(2,2))
```


## 三维空间的欧氏距离
三维空间两点a(x1,y1,z1)与b(x2,y2,z2)间的欧氏距离

$$d12 =\sqrt{(x_{1}-x_{2})^2+(y_{1}-y_{2})^2+(z_{1}-z_{2})^2}$$
python 实现为：
```
def threePointDistance(a,b):
	d = sqrt( (a[0]-b[0])**2 + (a[1]-b[1])**2 + (a[2]-b[2])**2 )
	return d

print 'a,b 三维距离为：',threePointDistance((1,1,1),(2,2,2))
```

## 多维空间的欧氏距离
两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的欧氏距离

$$ 
\sqrt{\sum_{n}^{k=1}(x_{1k}-x_{2k})^2 }
$$
python 实现为：

```
def distance(a,b):
	sum = 0
	for i in range(len(a)):
		sum += (a[i]-b[i])**2
	return sqrt(sum)

print 'a,b 多维距离为：',distance((1,1,2,2),(2,2,4,4))
```
这里传入的参数可以是任意维的，该公式也适应上边的二维和三维

# 标准欧氏距离
标准化欧氏距离是针对简单欧氏距离的缺点而作的一种改进方案。标准欧氏距离的思路：既然数据各维分量的分布不一样，好吧！那我先将各个分量都“标准化”到均值、方差相等吧。均值和方差标准化到多少呢？这里先复习点统计学知识吧，假设样本集X的均值(mean)为m，标准差(standard deviation)为s，那么X的“标准化变量”表示为：

　　而且标准化变量的数学期望为0，方差为1。因此样本集的标准化过程(standardization)用公式描述就是：
　　
$$
X^* = \frac{X-m}{s}
$$
标准化后的值 =  ( 标准化前的值  － 分量的均值 ) /分量的标准差

经过简单的推导就可以得到两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的标准化欧氏距离的公式：

$$
d_{12} =\sqrt {\sum_{k=1}^{n} (\frac{x_{1k}-x_{2k}}{s_{k}})^2}
$$
如果将方差的倒数看成是一个权重，这个公式可以看成是一种加权欧氏距离(Weighted Euclidean distance)。

python 实现为
```
def moreBZOSdis(a,b):
    sumnum = 0
    for i in range(len(a)):
        # 计算si 分量标准差
        avg = (a[i]-b[i])/2
        si = sqrt( (a[i] - avg) ** 2 + (b[i] - avg) ** 2 )
        sumnum += ((a[i]-b[i])/si ) ** 2
	
    return sqrt(sumnum)

print 'a,b 标准欧式距离：',moreBZOSdis((1,2,1,2),(3,3,3,4))
```

# 曼哈顿距离
又称为城市街区距离（City Block distance）, 想象你在曼哈顿要从一个十字路口开车到另外一个十字路口，驾驶距离是两点间的直线距离吗？显然不是，除非你能穿越大楼。实际驾驶距离就是这个“曼哈顿距离”。而这也是曼哈顿距离名称的来源。同样曼哈顿距离也分为二维，三维和多维。

在计程车几何学中，一个圆是由从圆心向各个固定曼哈顿距离标示出来的点围成的区域，因此这种圆其实就是旋转了45度的正方形。如果有一群圆，且任两圆皆相交，则整群圆必在某点相交；因此曼哈顿距离会形成一个超凸度量空间。

这里有一篇人脸表情分类的论文采用的曼哈顿距离进行计算的，[一种人脸表情分类的新方法——Manhattan距离](http://download.csdn.net/detail/gamer_gyt/9899825)

## 二维曼哈顿距离
二维平面两点a(x1,y1)与b(x2,y2)间的曼哈顿距离

$$
d12 =\left | x_{1}-x_{2} \right |  + \left |y_{1}-y_{2}  \right |
$$
python实现为
```
def twoMHDdis(a,b):
    return abs(a[0]-b[0])+abs(a[1]-b[1])

print 'a,b 二维曼哈顿距离为：', twoMHDdis((1,1),(2,2)) 
```


## 三维曼哈顿距离
三维平面两点a(x1,y1,z1)与b(x2,y2,z2)间的曼哈顿距离

$$
d12 =\left | x_{1}-x_{2} \right |  + \left |y_{1}-y_{2}  \right | + \left |z_{1}-z_{2}  \right |
$$
python实现为
```
def threeMHDdis(a,b):
	return abs(a[0]-b[0])+abs(a[1]-b[1]) + abs(a[2]-b[2])
 
print 'a,b 三维曼哈顿距离为：', threeMHDdis((1,1,1),(2,2,2)) 
```

## 多维曼哈顿距离
多维平面两点a(x1,y1)与b(x2,y2)间的曼哈顿距离
$$
d12 = \sum_{k=1}^{n} \left | x_{1k} - x_{2k} \right |
$$
python实现为
```
def moreMHDdis(a,b):
    sum = 0 
    for i in range(len(a)):
        sum += abs(a[i]-b[i])
    return sum

print 'a,b 多维曼哈顿距离为：', moreMHDdis((1,1,1,1),(2,2,2,2)) 
```
由于维距离计算是比较灵活的，所以也同样适合二维和三维。

# 切比雪夫距离
切比雪夫距离（Chebyshev Distance）的定义为：max( | x2-x1 | , |y2-y1 | , ... ), 切比雪夫距离用的时候数据的维度必须是三个以上，这篇文章中[曼哈顿距离，欧式距离，明式距离，切比雪夫距离区别](http://blog.csdn.net/jerry81333/article/details/52632687) 给了一个很形象的解释如下：
```
比如，有同样两个人，在纽约准备到北京参拜天安门，同一个地点出发的话，按照欧式距离来计算，是完全一样的。

但是按照切比雪夫距离，这是完全不同的概念了。

譬如，其中一个人是土豪，另一个人是中产阶级，第一个人就能当晚直接头等舱走人，而第二个人可能就要等机票什么时候打折再去，或者选择坐船什么的。

这样来看的话，距离是不是就不一样了呢？

或者还是不清楚，我再说的详细点。

同样是这两个人，欧式距离是直接算最短距离的，而切比雪夫距离可能还得加上财力，比如第一个人财富值100，第二个只有30，虽然物理距离一样，但是所包含的内容却是不同的。
```

## 二维切比雪夫距离

二维平面两点a(x1,y1)与b(x2,y2)间的切比雪夫距离

$$
d_{12} = max( \left | x_{1} - x_{2} \right | , \left | y_{1} - y_{2} \right |)
$$
python 实现为

```
def twoQBXFdis(a,b):
    return max( abs(a[0]-b[0]), abs(a[1]-b[1]))

print 'a,b二维切比雪夫距离：' , twoQBXFdis((1,2),(3,4))
```


## 多维切比雪夫距离

两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的切比雪夫距离
$$
d12 = max_{i\epsilon n}( \left | x_{1i} - x_{2i} \right | )
$$

python 实现为
```
def moreQBXFdis(a,b):
    maxnum = 0
    for i in range(len(a)):
        if abs(a[i]-b[i]) > maxnum:
            maxnum = abs(a[i]-b[i])
    return maxnum

print 'a,b多维切比雪夫距离：' , moreQBXFdis((1,1,1,1),(3,4,3,4))
```

# 马氏距离
有M个样本向量X1~Xm，协方差矩阵记为S，均值记为向量μ，则其中样本向量X到u的马氏距离表示为

$$
D(x) = \sqrt{(X-\mu )^TS^{-1}(X-\mu)}
$$
而其中向量Xi与Xj之间的马氏距离定义为
$$
D(X_{i},X_{j}) = \sqrt{(X_{i}-X_{j} )^TS^{-1}(X_{i}-X_{j} )}
$$
 若协方差矩阵是单位矩阵（各个样本向量之间独立同分布）,则公式就成了：
$$
D(X_{i},X_{j}) = \sqrt{(X_{i}-X_{j} )^T(X_{i}-X_{j} )}
$$
也就是欧氏距离了。

若协方差矩阵是对角矩阵，公式变成了标准化欧氏距离。

马氏距离的优缺点：量纲无关，排除变量之间的相关性的干扰。


# 夹角余弦
几何中夹角余弦可用来衡量两个向量方向的差异，机器学习中借用这一概念来衡量样本向量之间的差异。

## 二维空间向量的夹角余弦相似度
在二维空间中向量A(x1,y1)与向量B(x2,y2)的夹角余弦公式：

$$
\cos \theta  = \frac{x_{1}x_{2} + y_{1}y_{2}}{ \sqrt{ x_{1}^2+x_{2}^2 }\sqrt{ y_{1}^2+y_{2}^2 } }
$$
python 实现为
```
def twoCos(a,b):
    cos = (a[0]*b[0]+a[1]*b[1]) / (sqrt(a[0]**2 + b[0]**2) * sqrt(a[1]**2 + b[1]**2) )

    return cos
print 'a,b 二维夹角余弦距离：',twoCos((1,1),(2,2))
```


## 多维空间向量的夹角余弦相似度
两个n维样本点a(x11,x12,…,x1n)和b(x21,x22,…,x2n)的夹角余弦

类似的，对于两个n维样本点a(x11,x12,…,x1n)和b(x21,x22,…,x2n)，可以使用类似于夹角余弦的概念来衡量它们间的相似程度。
$$
\cos \theta  = \frac{a \cdot  b}{\left | a \right | \left | b \right |}
$$
即：
$$
\cos \theta  = \frac{ \sum_{k=1}^{n} x_{1k}x_{2k} }{ \sqrt{ \sum_{k=1}^{n}x_{1k}^2 }\sqrt{ \sum_{k=1}^{n} x_{2k}^2 } }
$$
python实现为
```
def moreCos(a,b):
    sum_fenzi = 0.0
    sum_fenmu_1,sum_fenmu_2 = 0,0
    for i in range(len(a)):
        sum_fenzi += a[i]*b[i]
        sum_fenmu_1 += a[i]**2 
        sum_fenmu_2 += b[i]**2 

    return sum_fenzi/( sqrt(sum_fenmu_1) * sqrt(sum_fenmu_2) )
print 'a,b 多维夹角余弦距离：',moreCos((1,1,1,1),(2,2,2,2))
```

夹角余弦取值范围为[-1,1]。夹角余弦越大表示两个向量的夹角越小，夹角余弦越小表示两向量的夹角越大。当两个向量的方向重合时夹角余弦取最大值1，当两个向量的方向完全相反夹角余弦取最小值-1。

# 闵可夫斯基距离

闵氏距离不是一种距离，而是一组距离的定义
## 定义
两个n维变量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的闵可夫斯基距离定义为：
$$
\sqrt[p]{ \sum_{k=1}^{n} \left | x_{1k}-x_{2k} \right |^p} 
$$

其中p是一个变参数。

当p=1时，就是曼哈顿距离

当p=2时，就是欧氏距离

当p→∞时，就是切比雪夫距离

根据变参数的不同，闵氏距离可以表示一类的距离。

## 闵氏距离的缺点
闵氏距离，包括曼哈顿距离、欧氏距离和切比雪夫距离都存在明显的缺点。

举个例子：二维样本(身高,体重)，其中身高范围是150 ~ 190，体重范围是50 ~ 60，有三个样本：a(180,50)，b(190,50)，c(180,60)。那么a与b之间的闵氏距离（无论是曼哈顿距离、欧氏距离或切比雪夫距离）等于a与c之间的闵氏距离，但是身高的10cm真的等价于体重的10kg么？因此用闵氏距离来衡量这些样本间的相似度很有问题。

简单说来，闵氏距离的缺点主要有两个：(1)将各个分量的量纲(scale)，也就是“单位”当作相同的看待了。(2)没有考虑各个分量的分布（期望，方差等)可能是不同的。


# 汉明距离

## 定义
两个等长字符串s1与s2之间的汉明距离定义为将其中一个变为另外一个所需要作的最小替换次数。例如字符串“1111”与“1001”之间的汉明距离为2。

应用：信息编码（为了增强容错性，应使得编码间的最小汉明距离尽可能大）。

## python 实现
```
def hanmingDis(a,b):
    sumnum = 0
    for i in range(len(a)):
        if a[i]!=b[i]:
            sumnum += 1
    return sumnum

print 'a,b 汉明距离：',hanmingDis((1,1,2,3),(2,2,1,3))
```

# 杰卡德距离 & 杰卡德相似系数
## 杰卡德距离
与杰卡德相似系数相反的概念是杰卡德距离(Jaccard distance)。杰卡德距离可用如下公式表示：
$$
J_{\delta} (A,B) = \frac{| A \bigcup B | - | A \bigcap B |}{| A \bigcup B |}
$$
杰卡德距离用两个集合中不同元素占所有元素的比例来衡量两个集合的区分度。

python 实现
```
def jiekadeDis(a,b):
    set_a = set(a)
    set_b = set(b)
    dis = float(len( (set_a | set_b) - (set_a & set_b) ) )/ len(set_a | set_b)
    return dis

print 'a,b 杰卡德距离：', jiekadeDis((1,2,3),(2,3,4))
```

## 杰卡德相似系数
两个集合A和B的交集元素在A，B的并集中所占的比例，称为两个集合的杰卡德相似系数，用符号J(A,B)表示。
$$
J(A,B) = \frac{| A \bigcap B |}{| A \bigcup B |}
$$
杰卡德相似系数是衡量两个集合的相似度一种指标。

python 实现
```
def jiekadeXSDis(a,b):
    set_a = set(a)
    set_b = set(b)
    dis = float(len(set_a & set_b)  )/ len(set_a | set_b)
    return dis

print 'a,b 杰卡德相似系数：', jiekadeXSDis((1,2,3),(2,3,4))
```

## 杰卡德相似系数与杰卡德距离的应用
可将杰卡德相似系数用在衡量样本的相似度上。

　　样本A与样本B是两个n维向量，而且所有维度的取值都是0或1。例如：A(0111)和B(1011)。我们将样本看成是一个集合，1表示集合包含该元素，0表示集合不包含该元素。

p ：样本A与B都是1的维度的个数

q ：样本A是1，样本B是0的维度的个数

r ：样本A是0，样本B是1的维度的个数

s ：样本A与B都是0的维度的个数



那么样本A与B的杰卡德相似系数可以表示为：

这里p+q+r可理解为A与B的并集的元素个数，而p是A与B的交集的元素个数。

而样本A与B的杰卡德距离表示为：
$$
J= \frac{p}{p+q+r}
$$

# 相关系数 & 相关距离
## 相关系数
$$
\rho_{XY} = \frac{Cov(X,Y)}{\sqrt{D(X)} \sqrt{D(Y)}}=\frac{ E( (X-EX) (Y-EY) ) }{ \sqrt{D(X)} \sqrt{D(Y)} }
$$
相关系数是衡量随机变量X与Y相关程度的一种方法，相关系数的取值范围是[-1,1]。相关系数的绝对值越大，则表明X与Y相关度越高。当X与Y线性相关时，相关系数取值为1（正线性相关）或-1（负线性相关）。

python 实现
相关系数可以利用numpy库中的corrcoef函数来计算
例如 对于矩阵a,numpy.corrcoef(a)可计算行与行之间的相关系数，numpy.corrcoef(a,rowvar=0)用于计算各列之间的相关系数，输出为相关系数矩阵。
```
from numpy import  *
a = array([[1, 1, 2, 2, 3],  
       [2, 2, 3, 3, 5],  
       [1, 4, 2, 2, 3]]) 

print corrcoef(a)

>>array([[ 1.        ,  0.97590007,  0.10482848],
       [ 0.97590007,  1.        ,  0.17902872],
       [ 0.10482848,  0.17902872,  1.        ]])

print corrcoef(a,rowvar=0)

>>array([[ 1.        , -0.18898224,  1.        ,  1.        ,  1.        ],
       [-0.18898224,  1.        , -0.18898224, -0.18898224, -0.18898224],
       [ 1.        , -0.18898224,  1.        ,  1.        ,  1.        ],
       [ 1.        , -0.18898224,  1.        ,  1.        ,  1.        ],
       [ 1.        , -0.18898224,  1.        ,  1.        ,  1.        ]])
```

## 相关距离

$$
D_{xy} = 1 - \rho _{XY}
$$

python 实现（基于相关系数）
同样针对矩阵a
```
# 行之间的相关距离
ones(shape(corrcoef(a)),int) - corrcoef(a)

>>array([[ 0.        ,  0.02409993,  0.89517152],
       [ 0.02409993,  0.        ,  0.82097128],
       [ 0.89517152,  0.82097128,  0.        ]])
       
       
# 列之间的相关距离
ones(shape(corrcoef(a,rowvar = 0)),int) - corrcoef(a,rowvar = 0)

>>array([[ 0.        ,  1.18898224,  0.        ,  0.        ,  0.        ],
       [ 1.18898224,  0.        ,  1.18898224,  1.18898224,  1.18898224],
       [ 0.        ,  1.18898224,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  1.18898224,  0.        ,  0.        ,  0.        ],
       [ 0.        ,  1.18898224,  0.        ,  0.        ,  0.        ]])

```


# 信息熵

信息熵并不属于一种相似性度量，是衡量分布的混乱程度或分散程度的一种度量。分布越分散(或者说分布越平均)，信息熵就越大。分布越有序（或者说分布越集中），信息熵就越小。

计算给定的样本集X的信息熵的公式：

$$
Entropy(X) = \sum_{i=1}^{n} -p_{i} log_{2}p_{i} 
$$

参数的含义：

n：样本集X的分类数

pi：X中第i类元素出现的概率

信息熵越大表明样本集S分类越分散，信息熵越小则表明样本集X分类越集中。。当S中n个分类出现的概率一样大时（都是1/n），信息熵取最大值log2(n)。当X只有一个分类时，信息熵取最小值0

python进行计算和实现可参考：
http://blog.csdn.net/autoliuweijie/article/details/52244246